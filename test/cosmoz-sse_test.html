<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes"
		/>

		<title>cosmoz-sse test</title>

		<script src="../../webcomponentsjs/webcomponents-loader.js"></script>
		<script src="../../web-component-tester/browser.js"></script>

		<link rel="import" href="../cosmoz-sse.html" />
	</head>
	<body>
		<test-fixture id="BasicTestFixture">
			<template>
				<cosmoz-sse url="https://localhost:8000"></cosmoz-sse>
			</template>
		</test-fixture>

		<test-fixture id="NoUrlTestFixture">
			<template>
				<cosmoz-sse></cosmoz-sse>
			</template>
		</test-fixture>

		<test-fixture id="NamedEventsTestFixture">
			<template>
				<cosmoz-sse
					url="https://localhost:8000"
					events="[&quot;ping&quot;]"
				></cosmoz-sse>
			</template>
		</test-fixture>

		<test-fixture id="NamedEventsAsTextTestFixture">
			<template>
				<cosmoz-sse
					url="https://localhost:8000"
					events="[&quot;ping&quot;]"
					handle-as="text"
				></cosmoz-sse>
			</template>
		</test-fixture>
		<script>
			const originalEventSource = window.EventSource;

			const eventWithData = (event, data) => {
				const e = new CustomEvent(event);
				e.data = data;
				return e;
			};

			describe('cosmoz-sse', () => {
				let eventSourceInstance;

				beforeEach(() => {
					// stubbing EventSource with sinon.createStubInstance does not work,
					// so we have to manually create the stub class
					const __events = new EventTarget();
					eventSourceInstance = {
						__dispatch: __events.dispatchEvent.bind(__events),
						addEventListener: __events.addEventListener.bind(__events),
						removeEventListener: __events.removeEventListener.bind(__events),
						close: sinon.spy()
					};

					const StubEventSource = sinon.spy(() => eventSourceInstance);
					window.EventSource = StubEventSource;
				});

				afterEach(() => {
					window.EventSource = originalEventSource;
				});

				it('connects to the provided url', () => {
					const element = fixture('BasicTestFixture');

					expect(window.EventSource).to.have.been.called;
					expect(window.EventSource).to.have.been.calledWith(
						'https://localhost:8000'
					);
				});

				it('does not connect if no url is specified', () => {
					const element = fixture('NoUrlTestFixture');

					expect(window.EventSource).to.not.have.been.called;
				});

				it('fires the `open` event when the connection is established', () => {
					const spy = sinon.spy();
					const element = fixture('BasicTestFixture');
					element.addEventListener('open', spy);

					eventSourceInstance.__dispatch(new CustomEvent('open'));
					expect(spy).to.have.been.called;
				});

				it('fires the `error` event when the connection fails', () => {
					const spy = sinon.spy();
					const element = fixture('BasicTestFixture');
					element.addEventListener('error', spy);

					eventSourceInstance.__dispatch(new CustomEvent('error'));
					expect(spy).to.have.been.called;
				});

				it('allows subscribing to message events', () => {
					const spy = sinon.spy();
					const element = fixture('BasicTestFixture');
					element.addEventListener('message', spy);

					eventSourceInstance.__dispatch(eventWithData('message', 'x1'));
					eventSourceInstance.__dispatch(eventWithData('message', 'x2'));
					eventSourceInstance.__dispatch(eventWithData('message', 'x3'));

					expect(spy).to.have.been.calledThrice;
					expect(spy.firstCall).to.have.been.calledWithMatch({
						detail: { data: 'x1' }
					});
					expect(spy.secondCall).to.have.been.calledWithMatch({
						detail: { data: 'x2' }
					});
					expect(spy.thirdCall).to.have.been.calledWithMatch({
						detail: { data: 'x3' }
					});
				});

				it('allows subscribing to named events', () => {
					const spy = sinon.spy();
					const element = fixture('NamedEventsTestFixture');
					element.addEventListener('ping', spy);

					eventSourceInstance.__dispatch(
						eventWithData('ping', '{"test": true}')
					);

					expect(spy).to.have.been.calledOnce;
					expect(spy.firstCall).to.have.been.calledWithMatch({
						detail: { data: { test: true } }
					});
				});

				it('allows handling named events as text', () => {
					const spy = sinon.spy();
					const element = fixture('NamedEventsAsTextTestFixture');
					element.addEventListener('ping', spy);

					eventSourceInstance.__dispatch(
						eventWithData('ping', 'thisistext')
					);

					expect(spy).to.have.been.calledOnce;
					expect(spy.firstCall).to.have.been.calledWithMatch({
						detail: { data: 'thisistext' }
					});
				});

				it('closes the sse connection when removed from DOM and restores it when added back', () => {
					const spy = sinon.spy();
					const element = fixture('BasicTestFixture');
					const parent = element.parentNode
					element.addEventListener('message', spy);

					eventSourceInstance.__dispatch(eventWithData('message', 'x1'));

					parent.removeChild(element)

					eventSourceInstance.__dispatch(eventWithData('message', 'x2'));

					parent.appendChild(element)

					eventSourceInstance.__dispatch(eventWithData('message', 'x3'));

					expect(spy).to.have.been.calledTwice;
					expect(spy.firstCall).to.have.been.calledWithMatch({
						detail: { data: 'x1' }
					});
					expect(spy.secondCall).to.have.been.calledWithMatch({
						detail: { data: 'x3' }
					});
				});
			});
		</script>
	</body>
</html>
